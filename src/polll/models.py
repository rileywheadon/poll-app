import enum
from typing import List
from datetime import datetime, timezone
from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
import sqlalchemy as sa
import sqlalchemy.orm as so

# Base class for declarative class definitions
class Base(so.DeclarativeBase):

    # Define a custom constraint naming convention
    metadata = sa.MetaData(naming_convention={
        "ix": 'ix_%(column_0_label)s',
        "uq": "uq_%(table_name)s_%(column_0_name)s",
        "ck": "ck_%(table_name)s_%(constraint_name)s",
        "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
        "pk": "pk_%(table_name)s"
    })

# BaseMixin class for simpler CRUD operations
class BaseMixin(object):
    @classmethod
    def create(cls, **kw):
        obj = cls(**kw)
        db.session.add(obj)
        db.session.commit()
        return obj


# Initialize a database using DeclarativeBase
db = SQLAlchemy(model_class = Base)

# Define enumeration for gender
class Gender(enum.Enum):
    MALE = 1
    FEMALE = 2
    NON_BINARY = 3

# Define enumeration for poll type
class PollType(enum.Enum):
    CHOOSE_ONE = 1
    CHOOSE_MANY = 2
    NUMERIC_STAR = 3
    NUMERIC_SCALE = 4
    RANKED_POLL = 5
    TIER_LIST = 7

# Define enumeration for tiers
class Tier(enum.Enum):
    S = 1
    A = 2
    B = 3
    C = 4
    D = 5
    F = 6


# NOTE:Tables are automatically generated by FLASK-SQLAlchemy
class User(UserMixin, BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    username = so.mapped_column(sa.String(30))
    email = so.mapped_column(sa.String, unique=True)
    age = so.mapped_column(sa.Integer, nullable = True)
    gender = so.mapped_column(sa.Enum(Gender), nullable = True)
    continent = so.mapped_column(sa.String, nullable = True)
    country = so.mapped_column(sa.String, nullable = True)
    region = so.mapped_column(sa.String, nullable = True)
    city = so.mapped_column(sa.String, nullable = True)
    date_created = so.mapped_column(sa.DateTime(timezone = True), default = lambda: datetime.now(timezone.utc))
    last_active = so.mapped_column(sa.DateTime(timezone = True))

    responses: so.Mapped[List["Response"]] = so.relationship("Response", back_populates="user")
    polls: so.Mapped[List["Poll"]] = so.relationship("Poll", back_populates="user")


# Association table for polls and tags
poll_tag_association = sa.Table(
    "poll_tag_association",
    Base.metadata,
    sa.Column("poll_id", sa.ForeignKey("poll.id"), primary_key = True),
    sa.Column("tag_id", sa.ForeignKey("tag.id"), primary_key = True),
)

class Poll(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    user_id = so.mapped_column(sa.ForeignKey("user.id"))
    question = so.mapped_column(sa.String, nullable = False)
    poll_type = so.mapped_column(sa.Enum(PollType), server_default = "CHOOSE_ONE", nullable = False)
    reveals = so.mapped_column(sa.Integer, server_default = "0", nullable = False)
    reports = so.mapped_column(sa.Integer, server_default = "0", nullable = False)
    date_created = so.mapped_column(sa.DateTime(timezone = True), default = lambda: datetime.now(timezone.utc))

    user : so.Mapped["User"] = so.relationship("User", back_populates="polls")
    tags : so.Mapped[List["Tag"]] = so.relationship("Tag", secondary = poll_tag_association, back_populates="polls")
    responses : so.Mapped[List["Response"]] = so.relationship("Response", back_populates="poll")
    answers : so.Mapped[List["PollAnswer"]] = so.relationship("PollAnswer", back_populates="poll")

    def __discrete_data(self, answer):
        count = (db.session
            .query(DiscreteResponse)
            .filter(DiscreteResponse.answer_id == answer.id)
            .count()
        )

        return {"id": answer.id, "text": answer.answer, "count": count}

    def __numeric_data(self):
        responses = (db.session
            .query(NumericResponse)
            .join(NumericResponse.response)
            .filter(Response.poll_id == self.id)
            .all()
        )

        return [r.value for r in responses]

    def __ranked_data(self, answer):
        responses = (db.session
            .query(RankedResponse)
            .filter(RankedResponse.answer_id == answer.id)
        )

        rankings = [r.rank for r in responses]
        return {"id": answer.id, "text": answer.answer, "rankings": rankings}

    def __tiered_data(self, answer):
        responses = (db.session
            .query(TieredResponse)
            .filter(TieredResponse.answer_id == answer.id)
        )

        tiers = [r.tier.name for r in responses]
        return {"id": answer.id, "text": answer.answer, "tiers": tiers}

class Tag(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    name = so.mapped_column(sa.String, nullable = False)

    polls : so.Mapped[List["Poll"]] = so.relationship("Poll", secondary = poll_tag_association, back_populates="tags")


class PollAnswer(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    poll_id = so.mapped_column(sa.ForeignKey("poll.id"))
    answer = so.mapped_column(sa.String, nullable = False)

    poll : so.Mapped["Poll"] = so.relationship("Poll", back_populates="answers")
    discrete_responses : so.Mapped[List["DiscreteResponse"]] = so.relationship("DiscreteResponse", back_populates = "answer")
    ranked_responses : so.Mapped[List["RankedResponse"]] = so.relationship("RankedResponse", back_populates = "answer")
    tiered_responses : so.Mapped[List["TieredResponse"]] = so.relationship("TieredResponse", back_populates = "answer")


class Response(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    user_id = so.mapped_column(sa.ForeignKey("user.id"))
    poll_id = so.mapped_column(sa.ForeignKey("poll.id"))
    timestamp = so.mapped_column(sa.DateTime, default = lambda: datetime.now(timezone.utc))

    user : so.Mapped["User"] = so.relationship("User", back_populates="responses")
    poll : so.Mapped["Poll"] = so.relationship("Poll", back_populates="responses")
    numeric_responses : so.Mapped["NumericResponse"] = so.relationship("NumericResponse", back_populates = "response")
    discrete_responses : so.Mapped["DiscreteResponse"] = so.relationship("DiscreteResponse", back_populates = "response")
    ranked_responses : so.Mapped["RankedResponse"] = so.relationship("RankedResponse", back_populates = "response")
    tiered_responses : so.Mapped["TieredResponse"] = so.relationship("TieredResponse", back_populates = "response")

    def __str__(self):
        return ("Response("
            f"user_id={self.user_id}, " 
            f"poll_id={self.poll_id}, "
            f"timestamp={self.timestamp}"
        ")")


class NumericResponse(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    response_id = so.mapped_column(sa.ForeignKey("response.id"))
    value = so.mapped_column(sa.Integer, nullable = False)

    response : so.Mapped["Response"] = so.relationship("Response", back_populates = "numeric_responses")

    def __str__(self):
        return ("NumericResponse("
            f"value={self.value}, " 
            f"response_id={self.response_id}"
        ")")


class DiscreteResponse(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    answer_id = so.mapped_column(sa.ForeignKey("poll_answer.id"))
    response_id = so.mapped_column(sa.ForeignKey("response.id"))

    response : so.Mapped["Response"] = so.relationship("Response", back_populates = "discrete_responses")
    answer : so.Mapped["PollAnswer"] = so.relationship("PollAnswer", back_populates = "discrete_responses")

    def __str__(self):
        return ("DiscreteResponse("
            f"answer={self.answer.answer}, " 
            f"answer_id={self.answer_id}, "
            f"response_id={self.response_id}"
        ")")

class RankedResponse(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    answer_id = so.mapped_column(sa.ForeignKey("poll_answer.id"))
    response_id = so.mapped_column(sa.ForeignKey("response.id"))
    rank = so.mapped_column(sa.Integer, nullable = False)

    response : so.Mapped["Response"] = so.relationship("Response", back_populates = "ranked_responses")
    answer : so.Mapped["PollAnswer"] = so.relationship("PollAnswer", back_populates = "ranked_responses")

    def __str__(self):
        return ("RankedResponse("
            f"rank={self.rank}, " 
            f"answer={self.answer.answer}, "
            f"answer_id={self.answer_id}, "
            f"response_id={self.response_id}"
        ")")


class TieredResponse(BaseMixin, db.Model):
    id = so.mapped_column(sa.Integer, primary_key = True)
    answer_id = so.mapped_column(sa.ForeignKey("poll_answer.id"))
    response_id = so.mapped_column(sa.ForeignKey("response.id"))
    tier = so.mapped_column(sa.Enum(Tier), nullable = False)

    response : so.Mapped["Response"] = so.relationship("Response", back_populates = "tiered_responses")
    answer : so.Mapped["PollAnswer"] = so.relationship("PollAnswer", back_populates = "tiered_responses")

    def __str__(self):
        return ("RankedResponse("
            f"tier={self.tier}, " 
            f"answer={self.answer.answer}, "
            f"answer_id={self.answer_id}, "
            f"response_id={self.response_id}"
        ")")
